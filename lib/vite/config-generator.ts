import fs from 'fs';
import path from 'path';
import { findDefineConfigCalls } from './config-scanner';
import type { ConfigEntry, DynamicConfigOptions } from './types';

/**
 * Generates configuration file based on found defineConfigEntry calls
 */
export function generateConfigFile(options: DynamicConfigOptions = {}): void {
  console.time('Generated config file in');

  const outputPath = 'src/dynamicConfig.gen.ts';

  const configEntries = findDefineConfigCalls(options);

  if (configEntries.length === 0) {
    console.warn('âš ï¸ No defineConfigEntry calls found');
    console.timeEnd('Generated config file in');
    return;
  }

  const generatedCode = buildConfigFileContent(configEntries);

  const fullOutputPath = path.resolve(outputPath);
  fs.writeFileSync(fullOutputPath, generatedCode, 'utf8');
  console.log(
    `âœ… Found ${configEntries.length} config(s):`,
    configEntries.map((c) => c.name)
  );
  console.timeEnd('Generated config file in');
}

/**
 * Builds the content of generated config file
 */
function buildConfigFileContent(configEntries: ConfigEntry[]): string {
  const imports = generateImports(configEntries);
  const configObject = generateConfigObject(configEntries);
  const typeDefinition = generateTypeDefinition(configEntries);
  const configNames = configEntries.map((c) => c.name).join(', ');

  return `// ðŸ¤– AUTO-GENERATED FILE - DO NOT EDIT MANUALLY
// This file is automatically generated based on defineConfigEntry calls
// Found configs: ${configNames}

${imports}

export const generateConfig = (sources: { json?: object; env?: object }) => ({
${configObject}
});

export type AppConfig = {
${typeDefinition}
};

// Augment the getConfig function to use AppConfig as default
declare module '@lasmedia/dynamic-config' {
  function getConfig(): AppConfig;
}
`;
}

/**
 * Generates imports section
 */
function generateImports(configEntries: ConfigEntry[]): string {
  // Group imports by file path
  const importGroups = new Map<string, string[]>();

  configEntries.forEach(({ filePath, exportName }) => {
    const importPath = filePath.replace(/\.tsx?$/, '').replace(/src/g, '.');

    if (!importGroups.has(importPath)) {
      importGroups.set(importPath, []);
    }
    importGroups.get(importPath)!.push(exportName);
  });

  // Generate import statements with grouped exports
  return Array.from(importGroups.entries())
    .map(([importPath, exportNames]) => {
      const uniqueExportNames = [...new Set(exportNames)]; // Remove duplicates
      return `import { ${uniqueExportNames.join(', ')} } from '${importPath}';`;
    })
    .join('\n');
}

/**
 * Generates config object
 */
function generateConfigObject(configEntries: ConfigEntry[]): string {
  return configEntries
    .map(({ name, exportName }) => {
      return `  ${name}: ${exportName}.parse(sources),`;
    })
    .join('\n');
}

/**
 * Generates type definition
 */
function generateTypeDefinition(configEntries: ConfigEntry[]): string {
  return configEntries
    .map(({ name, filePath, exportName }) => {
      const importPath = filePath.replace(/\.tsx?$/, '').replace(/src/g, '.');
      return `  ${name}: ReturnType<typeof import('${importPath}').${exportName}.parse>;`;
    })
    .join('\n');
}
